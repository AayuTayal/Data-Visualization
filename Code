import panel as pn
import pygame
import csv
import time
from PIL import ImageOps
from PIL import Image
from IPython.display import display, clear_output
from threading import Thread
import io
import numpy as np

# Initialize Pygame
pygame.init()

# Define box coordinates
BOX1_COORDINATES = ((32, 160), (162, 190))
BOX2_COORDINATES = ((32, 330), (162, 360))
BOX3_COORDINATES = ((32, 502), (162, 532))
BOX4_COORDINATES = ((18, 906), (148, 936))
BOX5_COORDINATES = ((730, 46), (860, 76))
BOX6_COORDINATES = ((319, 716), (449, 746))
BOX7_COORDINATES = ((456, 481), (586, 511))
BOX8_COORDINATES = ((650, 404), (780, 434))
BOX9_COORDINATES = ((498, 806), (628, 834))
BOX10_COORDINATES = ((1562, 172), (1692, 202))
BOX11_COORDINATES = ((1486, 335), (1616, 365))
BOX12_COORDINATES = ((1486, 380), (1616, 410))
BOX13_COORDINATES = ((1486, 430), (1616, 460))
BOX14_COORDINATES = ((1281, 517), (1411, 547))
BOX15_COORDINATES = ((965, 550), (1095, 580))
BOX16_COORDINATES = ((1137, 550), (1265, 580))
BOX17_COORDINATES = ((1138, 932), (1268, 962))
BOX18_COORDINATES = ((1088, 850), (1218, 878))
BOX19_COORDINATES = ((1520, 764), (1650, 794))
BOX20_COORDINATES = ((1338, 150), (1468, 180))
BOX21_COORDINATES = ((642, 768), (772, 798))
BOX22_COORDINATES = ((1520, 476), (1650, 506))
BOX23_COORDINATES = ((43, 610), (173, 640))
BOX24_COORDINATES = ((43, 662), (173, 692))
BOX25_COORDINATES = ((43, 704), (173, 734))
BOX26_COORDINATES = ((43, 754), (173, 784))
BOX27_COORDINATES = ((43, 796), (173, 826))
BOX28_COORDINATES = ((43, 834), (173, 864))
BOX29_COORDINATES = ((1783, 228), (1913, 258))
BOX30_COORDINATES = ((1783, 276), (1913, 306))
BOX31_COORDINATES = ((1783, 313), (1913, 343))
BOX32_COORDINATES = ((1783, 356), (1913, 386))
BOX33_COORDINATES = ((1783, 396), (1913, 426))
BOX34_COORDINATES = ((1783, 437), (1913, 467))
BOX35_COORDINATES = ((1783, 478), (1913, 508))
BOX36_COORDINATES = ((1783, 519), (1913, 549))
BOX37_COORDINATES = ((1783, 701), (1913, 731))
BOX38_COORDINATES = ((1783, 749), (1913, 779))
BOX39_COORDINATES = ((1783, 786), (1913, 816))
BOX40_COORDINATES = ((1783, 829), (1913, 859))
BOX41_COORDINATES = ((1783, 870), (1913, 900))
BOX42_COORDINATES = ((323, 300), (453, 330))
BOX43_COORDINATES = ((323, 130), (453, 160))
BOX44_COORDINATES = ((323, 474), (453, 504))
BOX45_COORDINATES = ((388, 966), (518, 996))
BOX46_COORDINATES = ((1330, 6), (1460, 36))
BOX47_COORDINATES = ((1584, 100), (1714, 130))
BOX48_COORDINATES = ((1269, 645), (1399, 675))
BOX49_COORDINATES = ((1438, 930), (1568, 960))
BOX50_COORDINATES = ((1310, 766), (1440, 796))
BOX51_COORDINATES = ((840, 744), (970, 774))
BOX52_COORDINATES = ((908, 376), (1038, 406))


# Define constants
DAT_PATH = "d00_te.dat"
BOX_COORDINATES = [
    BOX1_COORDINATES, BOX2_COORDINATES, BOX3_COORDINATES, BOX4_COORDINATES, BOX5_COORDINATES, BOX6_COORDINATES, BOX7_COORDINATES, BOX8_COORDINATES, BOX9_COORDINATES, BOX10_COORDINATES, BOX11_COORDINATES,
    BOX12_COORDINATES, BOX13_COORDINATES, BOX14_COORDINATES, BOX15_COORDINATES, BOX16_COORDINATES, BOX17_COORDINATES, BOX18_COORDINATES, BOX19_COORDINATES, BOX20_COORDINATES, BOX21_COORDINATES, BOX22_COORDINATES, 
    BOX23_COORDINATES, BOX24_COORDINATES, BOX25_COORDINATES, BOX26_COORDINATES, BOX27_COORDINATES, BOX28_COORDINATES, BOX29_COORDINATES, BOX30_COORDINATES, BOX31_COORDINATES, BOX32_COORDINATES, BOX33_COORDINATES, 
    BOX34_COORDINATES, BOX35_COORDINATES, BOX36_COORDINATES, BOX37_COORDINATES, BOX38_COORDINATES, BOX39_COORDINATES, BOX40_COORDINATES, BOX41_COORDINATES, BOX42_COORDINATES, BOX43_COORDINATES, BOX44_COORDINATES, 
    BOX45_COORDINATES, BOX46_COORDINATES, BOX47_COORDINATES, BOX48_COORDINATES, BOX49_COORDINATES, BOX50_COORDINATES, BOX51_COORDINATES, BOX52_COORDINATES
]

# Function to read data from CSV file and store it as a matrix
def read_csv_to_matrix(csv_path):
    matrix = []
    with open(csv_path, "r") as file:
        reader = csv.reader(file)
        for row in reader:
            matrix.append(row)
    return matrix

# Load data from the file
matrix = read_csv_to_matrix(DAT_PATH)


# Define a flag to control the simulation state
is_running = False

# Define font
font = pygame.font.Font(None, 24)

row_index = 0

# Define groups of boxes with the same color
BOX_GROUPS = {
    "Group1": [BOX1_COORDINATES, BOX2_COORDINATES, BOX3_COORDINATES, BOX4_COORDINATES, BOX5_COORDINATES, BOX6_COORDINATES, BOX10_COORDINATES, BOX14_COORDINATES, BOX17_COORDINATES, 
               BOX19_COORDINATES, BOX42_COORDINATES, BOX43_COORDINATES, BOX44_COORDINATES, BOX45_COORDINATES, BOX46_COORDINATES, BOX47_COORDINATES, BOX48_COORDINATES, BOX49_COORDINATES, 
               BOX50_COORDINATES, BOX51_COORDINATES, BOX52_COORDINATES],
    "Group2": [BOX23_COORDINATES, BOX24_COORDINATES, BOX25_COORDINATES, BOX26_COORDINATES, BOX27_COORDINATES, BOX28_COORDINATES, BOX29_COORDINATES, BOX30_COORDINATES, BOX31_COORDINATES, 
               BOX32_COORDINATES, BOX33_COORDINATES, BOX34_COORDINATES, BOX35_COORDINATES, BOX36_COORDINATES, BOX37_COORDINATES, BOX38_COORDINATES, BOX39_COORDINATES, BOX40_COORDINATES, 
               BOX41_COORDINATES],
    "Group3": [BOX9_COORDINATES, BOX11_COORDINATES, BOX18_COORDINATES, BOX21_COORDINATES, BOX22_COORDINATES],
    "Group4": [BOX7_COORDINATES, BOX13_COORDINATES, BOX16_COORDINATES],
    "Group5": [BOX8_COORDINATES, BOX12_COORDINATES, BOX15_COORDINATES],
    "Group6": [BOX20_COORDINATES],
    
    
}

# Define colors for each group
GROUP_COLORS = {
    "Group1": (42, 46, 110),       # BLUE
    "Group2": (141, 48, 119),      # PINK
    "Group3": (191, 32, 50),       # RED
    "Group4": (39, 147, 89),       # GREEN
    "Group5": (237, 231, 35),      # GREEN
    "Group6": (99, 99, 99),        #GREY
}

# Function to generate Pygame image
def generate_pygame_image():
    global row_index
    image_path = "Dc2image.jpg"
    image = pygame.image.load(image_path)
    image = pygame.transform.scale(image, (1920, 1080))
    
    for group_name, boxes in BOX_GROUPS.items():
        group_color = GROUP_COLORS.get(group_name, (255, 255, 255))  # Default color is white
        for box in boxes:
            pygame.draw.rect(image, group_color, (*box[0], box[1][0] - box[0][0], box[1][1] - box[0][1]), 4)
    
    for index, box in enumerate(BOX_COORDINATES):
        if index < len(matrix):  # Check if there is enough data for this box
            row_data = matrix[row_index][0].split()[index]
            box_text = font.render(row_data, True, (255, 0, 0))
            # Calculate the center position of the box
            center_x = (box[0][0] + box[1][0]) // 2
            center_y = (box[0][1] + box[1][1]) // 2
            text_width, text_height = font.size(row_data)
            text_x = center_x - text_width // 2
            text_y = center_y - text_height // 2
            image.blit(box_text, (text_x, text_y))

    pygame_surface = pygame.surfarray.pixels3d(image)
    pil_image = Image.fromarray(pygame_surface[:, :, [0, 1, 2]])  # Direct conversion to PIL, skipping unnecessary transposes
    pil_image = pil_image.rotate(90, expand=True)
    pil_image = ImageOps.flip(pil_image)
    return pil_image


# Global flag to control the execution of the function
is_running = False

def generate_pygame_image2():
    global row_index
    image_path = "Dc2image.jpg"
    image = pygame.image.load(image_path)
    image = pygame.transform.scale(image, (1920, 1080))


    pygame_surface = pygame.surfarray.pixels3d(image)
    pil_image = Image.fromarray(pygame_surface[:, :, [0, 1, 2]])  # Direct conversion to PIL, skipping unnecessary transposes
    pil_image = pil_image.rotate(90, expand=True)
    pil_image = ImageOps.flip(pil_image)
    return pil_image

# Define Panel app
pn.extension()
start_button = pn.widgets.Button(name='Start', button_type='success', width=62)
stop_button = pn.widgets.Button(name='Stop', button_type='danger', width=62)
restart_button = pn.widgets.Button(name='Restart', button_type='primary', width=50)
reset_button = pn.widgets.Button(name='Reset', button_type='primary', width=62)
# Dropdown for fault detection technologies
fault_detection_select = pn.widgets.Select(name='Select Fault Detection Technology', 
                                           options=['PCA', 'Convolution Layer', 'GAF', 'RP'])
fault_detection_button = pn.widgets.Button(name='Detect Fault')




# Create a single image pane to display images
image_pane = pn.pane.PNG(width=800, embed=True)  #image_pane = pn.pane.PNG(width=1920, height=1080, embed=True),,,,,(width=1386, height=780, embed=True)

# Panel to display results
result_panel = pn.pane.Markdown("Result will be displayed here.")

layout = pn.Row(
    pn.Column(start_button, stop_button, reset_button, restart_button,fault_detection_select,fault_detection_button, result_panel,align="center"),
    image_pane
)

pil_image = generate_pygame_image2()
img_byte_arr = io.BytesIO()
pil_image.save(img_byte_arr, format='PNG')
image_pane.object = img_byte_arr.getvalue()    

    
def controlled_function():
    global is_running, row_index
    while is_running and row_index < 960:
        pil_image = generate_pygame_image()
        img_byte_arr = io.BytesIO()
        pil_image.save(img_byte_arr, format='PNG')
        image_pane.object = img_byte_arr.getvalue()
        time.sleep(1)
        row_index += 1

def start_function(event):
    global is_running, row_index
    if not is_running:
        is_running = True
        thread = Thread(target=controlled_function)
        thread.start()

def stop_function(event):
    global is_running, row_index
    is_running = False
    
def restart_function(event):
    global is_running, row_index
    if not is_running:
    #     is_running=False
        row_index=0
        start_function(event)
    
def reset_function(event):
    global is_running, row_index
    if is_running:
        is_running = False
    row_index = 0
    pil_image = generate_pygame_image()
    img_byte_arr = io.BytesIO()
    pil_image.save(img_byte_arr, format='PNG')
    image_pane.object = img_byte_arr.getvalue() 
    
# Sample function for fault detection (to be expanded with actual logic)
def detect_fault(technology, data):
    if technology == 'PCA':
        return "Detected fault using PCA"
    elif technology == 'Convolution Layer':
        return "Detected fault using Convolution Layer"
    elif technology == 'GAF':
        return "Detected fault using GAF"
    elif technology == 'RP':
        return "Detected fault using RP"
    else:
        return "Select a valid technology"
    
# Function to handle button click event
def on_fault_detection_button_click(event):
    selected_technology = fault_detection_select.value
    sample_data = np.random.rand(10, 10)  # Sample data (replace with actual data)
    result = detect_fault(selected_technology, sample_data)
    result_panel.object = result

# Link buttons to their respective functions
start_button.on_click(start_function)
stop_button.on_click(stop_function)
restart_button.on_click(restart_function)
reset_button.on_click(reset_function)
# Linking button click to the function
fault_detection_button.on_click(on_fault_detection_button_click)

# Display the layout
layout.servable()
